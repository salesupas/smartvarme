---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: []
autonomous: false

must_haves:
  truths:
    - "Developer can access WordPress admin at localhost:8080/wp-admin"
    - "Smartvarme theme is active and visible on frontend at localhost:8080"
    - "Smartvarme Core plugin is activated in Plugins list"
    - "Database imported from smartvarme_wp_zmmon.sql with all content intact"
    - "URLs in database point to localhost:8080 without serialization corruption"
    - "Autoloaded data in wp_options is under 800KB"
  artifacts: []
  key_links:
    - from: "smartvarme_wp_zmmon.sql"
      to: "wp-env MariaDB"
      via: "wp db import"
      pattern: "wp db import"
    - from: "wp-env MariaDB (old URLs)"
      to: "wp-env MariaDB (localhost URLs)"
      via: "wp search-replace --precise"
      pattern: "search-replace.*precise"
    - from: "wp_options autoload"
      to: "800KB threshold"
      via: "autoload audit and optimization"
      pattern: "autoload.*800"
---

<objective>
Start Docker environment, import production database, perform serialization-safe URL replacement, and optimize autoloaded data to under 800KB.

Purpose: Establish the working local WordPress site with real production data, proving the migration toolchain works correctly. This validates that all content, products, and settings survive the migration without data corruption.

Output: Running WordPress site at localhost:8080 with production data, correct local URLs, and optimized autoload size.
</objective>

<execution_context>
@/Users/salesup/.claude/get-shit-done/workflows/execute-plan.md
@/Users/salesup/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Start Docker environment and verify WordPress is running</name>
  <files></files>
  <action>
Start the Docker environment using @wordpress/env from the project root directory.

```bash
cd /path/to/Smartvarme2.0
wp-env start
```

After start, verify:
1. WordPress accessible at http://localhost:8080
2. Admin accessible at http://localhost:8080/wp-admin (credentials: admin/password -- wp-env defaults)
3. Smartvarme theme is present in Appearance > Themes

Activate the Smartvarme theme:
```bash
wp-env run cli wp theme activate smartvarme-theme
```

Activate the Smartvarme Core plugin:
```bash
wp-env run cli wp plugin activate smartvarme-core
```

Verify both are active:
```bash
wp-env run cli wp theme status smartvarme-theme
wp-env run cli wp plugin list --status=active
```

If port 8080 is already in use, check with `lsof -i :8080` and stop the conflicting process. Do NOT change the port -- the project is standardized on 8080.

If wp-env start fails due to Docker not running, provide clear error message directing user to start Docker Desktop first.
  </action>
  <verify>
1. `curl -s -o /dev/null -w "%{http_code}" http://localhost:8080` returns 200 or 301/302
2. `wp-env run cli wp theme status smartvarme-theme` shows "Active"
3. `wp-env run cli wp plugin is-active smartvarme-core` returns exit code 0
4. `wp-env run cli wp core version` shows 6.8+
  </verify>
  <done>
Docker environment running at localhost:8080 with WordPress 6.8+ on PHP 8.3. Smartvarme block theme is active. Smartvarme Core plugin is activated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Import production database and perform serialization-safe URL replacement</name>
  <files></files>
  <action>
**Step 1: Determine the production domain.**

Before importing, find the site URL in the SQL dump to know what to search-replace. Run:
```bash
grep -m 1 "siteurl" smartvarme_wp_zmmon.sql | head -c 500
```
Or check the first few option_value entries. The domain is likely `https://smartvarme.no` or `https://www.smartvarme.no`. Record the exact URL including protocol and any www prefix.

**Step 2: Import the database.**

Copy the SQL file into the Docker container and import:
```bash
# Copy SQL file to container
docker cp smartvarme_wp_zmmon.sql $(docker ps -q --filter "name=mysql"):/tmp/smartvarme_wp_zmmon.sql

# Import (this is a 255MB file, may take 1-3 minutes)
wp-env run cli wp db import /tmp/smartvarme_wp_zmmon.sql
```

If the above approach fails due to file size, try direct MySQL import:
```bash
# Alternative: pipe directly
wp-env run cli bash -c "mysql -u root -p'password' wordpress < /tmp/smartvarme_wp_zmmon.sql"
```

**Step 3: Verify import succeeded.**
```bash
wp-env run cli wp post count
wp-env run cli wp post list --post_type=product --format=count
wp-env run cli wp option get siteurl
wp-env run cli wp option get home
```

**Step 4: Run serialization-safe search-replace (DRY RUN FIRST).**

Replace production domain with localhost:8080. ALWAYS dry-run first:
```bash
wp-env run cli wp search-replace 'https://smartvarme.no' 'http://localhost:8080' \
  --dry-run \
  --all-tables \
  --precise \
  --report-changed-only
```

Also check for www variant:
```bash
wp-env run cli wp search-replace 'https://www.smartvarme.no' 'http://localhost:8080' \
  --dry-run \
  --all-tables \
  --precise \
  --report-changed-only
```

Review dry-run output. If it looks reasonable (hundreds/thousands of replacements across posts, options, meta), proceed with actual replacement:
```bash
wp-env run cli wp search-replace 'https://smartvarme.no' 'http://localhost:8080' \
  --all-tables \
  --precise \
  --skip-columns=guid

wp-env run cli wp search-replace 'https://www.smartvarme.no' 'http://localhost:8080' \
  --all-tables \
  --precise \
  --skip-columns=guid
```

Also handle http (non-SSL) variants if they exist:
```bash
wp-env run cli wp search-replace 'http://smartvarme.no' 'http://localhost:8080' \
  --dry-run --all-tables --precise --report-changed-only

wp-env run cli wp search-replace 'http://www.smartvarme.no' 'http://localhost:8080' \
  --dry-run --all-tables --precise --report-changed-only
```

Run actual replacement for any variants that showed matches.

**Step 5: Flush caches and rewrite rules.**
```bash
wp-env run cli wp cache flush
wp-env run cli wp rewrite flush
```

**Step 6: Verify site loads with correct URLs.**
```bash
wp-env run cli wp option get siteurl
wp-env run cli wp option get home
curl -s http://localhost:8080 | head -50
```

**Step 7: Re-activate theme and plugin** (import may have changed active theme):
```bash
wp-env run cli wp theme activate smartvarme-theme
wp-env run cli wp plugin activate smartvarme-core
```

Note: The database import will bring in the old theme (Astra) and all old plugins. That's expected -- the old plugins won't be mounted in wp-env and will show as inactive/missing. The important thing is our new theme and plugin are active.
  </action>
  <verify>
1. `wp-env run cli wp option get siteurl` returns "http://localhost:8080"
2. `wp-env run cli wp option get home` returns "http://localhost:8080"
3. `curl -s http://localhost:8080` returns HTML content (not error page)
4. `wp-env run cli wp post count` returns > 0 (content exists)
5. `wp-env run cli wp db query "SELECT COUNT(*) FROM wp_posts WHERE post_content LIKE '%smartvarme.no%';" --skip-column-names` returns 0 or very low number (most URLs replaced)
  </verify>
  <done>
Production database imported successfully. All URLs in database point to http://localhost:8080. Serialization integrity maintained (WP-CLI --precise flag used). Site loads at localhost:8080 with production content. Theme and plugin re-activated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit and optimize wp_options autoloaded data to under 800KB</name>
  <files></files>
  <action>
**Step 1: Measure current autoload size.**
```bash
wp-env run cli wp db query "SELECT ROUND(SUM(LENGTH(option_value)) / 1024, 2) AS autoload_kb FROM wp_options WHERE autoload IN ('yes', 'on', 'auto-on', 'auto');" --skip-column-names
```

Record the baseline value.

**Step 2: Identify top 20 autoloaded items by size.**
```bash
wp-env run cli wp db query "SELECT option_name, ROUND(LENGTH(option_value) / 1024, 2) AS size_kb FROM wp_options WHERE autoload IN ('yes', 'on', 'auto-on', 'auto') ORDER BY LENGTH(option_value) DESC LIMIT 20;"
```

**Step 3: Clean expired transients first (quick wins).**
```bash
wp-env run cli wp transient delete --all --expired
wp-env run cli wp transient delete --all
```

Remeasure autoload size after transient cleanup.

**Step 4: Disable autoload for options from plugins NOT used in new site.**

Identify options from old plugins that won't be active in the new site. Common candidates:
- `wordfence_*` options (security plugin not needed in local dev)
- `wf_*` options (Wordfence)
- `astra_*` options (old theme)
- `wp_fastest_cache_*` options (caching plugin)
- `wpseo_*` options that are large (Yoast SEO -- may keep some but disable autoload on large ones)
- `formidable_*` options (if large)
- `kadence_blocks_*` options
- `facebook_for_woocommerce_*` options
- `redirection_*` options (if large)

For each identified large option that belongs to an inactive plugin:
```bash
wp-env run cli wp option update <option_name> --autoload=no
```

Do NOT delete options -- just disable autoload. The data may be needed during later migration phases.

**Step 5: If still above 800KB, apply more aggressive optimization.**

Check for specific bloat patterns:
- Large serialized arrays in `_site_transient_*`
- Cron schedules: `cron` option can be large
- Widget data: `widget_*` options
- Rewrite rules: `rewrite_rules` option (can be large with many plugins)

For rewrite_rules specifically:
```bash
wp-env run cli wp rewrite flush
```
This regenerates rewrite rules based on only the active plugins (much smaller).

**Step 6: Final measurement and documentation.**
```bash
wp-env run cli wp db query "SELECT ROUND(SUM(LENGTH(option_value)) / 1024, 2) AS autoload_kb FROM wp_options WHERE autoload IN ('yes', 'on', 'auto-on', 'auto');" --skip-column-names
```

If still above 800KB, document what remains and why. If between 800KB-1MB, per research recommendation this is acceptable with a documented optimization plan for Phase 2.

Record: baseline size, after-transients size, final size, and top remaining autoloaded items in the plan summary.
  </action>
  <verify>
1. Final autoload size query returns value under 800 (KB):
   `wp-env run cli wp db query "SELECT ROUND(SUM(LENGTH(option_value)) / 1024, 2) AS autoload_kb FROM wp_options WHERE autoload IN ('yes', 'on', 'auto-on', 'auto');" --skip-column-names`
2. No critical WordPress options were accidentally disabled (site still loads):
   `curl -s -o /dev/null -w "%{http_code}" http://localhost:8080` returns 200/301/302
3. WordPress admin still accessible:
   `curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/wp-admin/` returns 200/301/302
  </verify>
  <done>
Autoloaded data is under 800KB (or documented plan exists if 800KB-1MB). Baseline, intermediate, and final sizes recorded. Transients cleaned, inactive plugin options de-autoloaded, rewrite rules regenerated. Site remains functional.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify all Phase 1 success criteria</name>
  <files></files>
  <action>
CHECKPOINT: Human visual verification of complete Phase 1 foundation.

What was built: Docker environment at localhost:8080, block theme with build system, custom plugin, imported database with serialization-safe migration, and optimized autoload.

Steps for the user to verify:
1. Open http://localhost:8080 in browser -- site should load with content from production database
2. Open http://localhost:8080/wp-admin -- admin panel should be accessible (admin/password)
3. Go to Appearance > Themes -- "Smartvarme" theme should show as active
4. Go to Plugins -- "Smartvarme Core" should show as active with no errors
5. Browse a few pages/posts -- content should be visible (old styling is expected, design comes in Phase 5)
6. Check browser console for JavaScript errors -- there should be none from the theme

Resume signal: Type "approved" if everything looks good, or describe any issues you see.
  </action>
  <verify>User confirms all 6 verification steps pass by typing "approved".</verify>
  <done>Human has visually confirmed: site loads at localhost:8080 with production content, admin is accessible, theme and plugin are active, and no JavaScript errors in console.</done>
</task>

</tasks>

<verification>
Phase 1 success criteria verification commands (run after all tasks complete):

1. **Docker at localhost:8080:** `curl -s -o /dev/null -w "%{http_code}" http://localhost:8080`
2. **Theme compiles:** `cd wp-content/themes/smartvarme-theme && npm run build` (exit code 0)
3. **Database imported without corruption:** `wp-env run cli wp post count` returns > 0 AND `wp-env run cli wp option get siteurl` returns "http://localhost:8080"
4. **Plugin activates:** `wp-env run cli wp plugin is-active smartvarme-core` (exit code 0)
5. **Autoload under 800KB:** `wp-env run cli wp db query "SELECT ROUND(SUM(LENGTH(option_value)) / 1024, 2) AS autoload_kb FROM wp_options WHERE autoload IN ('yes', 'on', 'auto-on', 'auto');" --skip-column-names` returns value < 800
</verification>

<success_criteria>
1. WordPress accessible at http://localhost:8080 with production content
2. WordPress admin accessible at http://localhost:8080/wp-admin
3. Smartvarme block theme active (verified via WP-CLI)
4. Smartvarme Core plugin active without errors (verified via WP-CLI)
5. All database URLs point to localhost:8080 (no smartvarme.no references in content)
6. wp_options autoloaded data is under 800KB
7. Human has visually confirmed site loads correctly in browser
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
